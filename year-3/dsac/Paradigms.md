# Greedy programming
**Overview:**  
The greedy paradigm involves making the best local (or immediate) choice at each step with the hope that these locally optimal solutions will lead to a globally optimal solution. Greedy algorithms are often simpler and run faster than other approaches, but they do not always guarantee an optimal solution.
**When It’s Useful:**
- **Optimal Solutions:**  
    Problems that exhibit the _greedy choice property_ and _optimal substructure._ Examples include activity selection, Huffman coding, and certain shortest-path problems in graphs (like using a greedy strategy in a weighted acyclic graph).
- **“Good-Enough” Solutions:**  
    When an optimal solution is hard to compute, or the problem is NP-complete (e.g., the knapsack problem under some constraints), greedy solutions can provide a near-optimal answer quickly.


# Recursion (with divide and conquor)

# Dynamic Programming

# Amortisation